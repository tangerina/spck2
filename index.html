<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title></title>
</head>
<body>
<textarea id="taTest" style="width:300px;height:200px;">
@1 t120 v128 o4 L4 ['C8.D-16'2,16]<E+2r
</textarea><br>
  <button id="btnTest">test</button>
</body>
<script>
var target = "";

var PITCH = {">" : +1, "<" : -1};
var KSIG = {"+" : +1, "-" : -1};

function getch(str, pos){
  return (pos < str.length) ? str[pos] : null;
}
function isws(c){ // check if the character is whitespace
  return (!(/\S/).exec(c));
}
function isdigit(c){
  return "1234567890".indexOf(c) >= 0;
}
function readint(str, pos){
  var buf = "";
  while(isdigit(getch(str, pos))){
    buf = buf + getch(str, pos++);
  }
  return {val: Number(buf), pos: pos};
}
function readdots(str, pos){
  var buf = "";
  while("." == getch(str, pos)){
    buf = buf + getch(str, pos++);
  }
  return {val: buf, pos: pos};
}

var TOKEN_TYPE = {"@":"ToneNo", "t":"Tempo", "o":"Octave", "l":"Length", "r":"Rest", ".": "Dot", "<":"OctUD", ">":"OctUD",
                  "c":"Note", "d":"Note", "e":"Note", "f":"Note", "g":"Note", "a":"Note", "b":"Note", 
                  "+":"Sig", "-":"Sig", "\,":"Comma", "[":"SqbrL", "]":"SqbrR", "'":"Chord", 
                  "1":"Number", "2":"Number", "3":"Number", "4":"Number", "5":"Number", 
                  "6":"Number", "7":"Number", "8":"Number", "9":"Number", "0":"Number"};

function gettokentype(c){
  return (c in TOKEN_TYPE) ? TOKEN_TYPE[c] : "Unknown";
}

var inchord = 0;
var CHORD_SUFFIX = ["L", "R"];

function tokenize(str, pos){
  var token = {type:null, val:null};
  
  while(isws(getch(str, pos))){ pos++; }
  
  var c = getch(str, pos);
  if (c) {
    var type = gettokentype(c);
    switch(type){
      case "Number":
        token.type = type;
        var result = readint(str, pos);
        token.val = result.val;
        pos = result.pos;
        break;
      case "Dot":
        token.type = type;
        var result = readdots(str, pos);
        token.val = result.val;
        pos = result.pos;
        break;
      case "ToneNo":
      case "Tempo":
      case "Octave":
      case "OctUD":
      case "Length":
      case "Sig":
      case "Comma":
      case "SqbrL":
      case "SqbrR":
      case "Note":
      case "Rest":
        token.type = type;
        token.val = c;
        pos++;
        break;
      case "Chord":
        token.type = type + CHORD_SUFFIX[inchord];
        inchord = 1 - inchord; // toggle
        token.val = c;
        pos++;
        break;
      default:
        token.type = type;
        token.val = c;
        pos++;
        console.log("unknown token [" + c + "]");
    }
  }
    
  return {token:token, pos:pos};
}
class Tree{
  constructor(){
    this.token = null;
    this.left = null;
    this.right = null;
  }
}
let root = new Tree();
function constructTree(tokens, tp, tree){
  if (!tokens[tp]) return;

  let tr = new Tree();
  let ltr = new Tree();
  let rtr = new Tree();
  
  switch (tokens[tp].type){
    case "SqbrL":// 値をとらないtoken
    case "ChordL":
    case "OctUD":
      tr.token = tokens[tp++];
      tr.left = ltr;
      tr.right = rtr;
      tree.right = tr;
      break;
    case "ChordR":
      tr.token = tokens[tp++];
      tr.left = ltr;
      tr.right = rtr;
      tree.right = tr;
      if (tokens[tp] && tokens[tp].type == "Number"){ // 音長はleft tokenに設定
        ltr.token = tokens[tp++];
      }
      if (tokens[tp] && tokens[tp].type == "Comma"){ // 分散和音
        tp++;
        if (tokens[tp] && tokens[tp].type == "Number"){ // latency
          tr.token.broken = tokens[tp++].val;
        } else{
          console.log("constructTree : Syntax error.", tokens[tp]);
          return;
        }
      }
      break;
    case "SqbrR":// 1つの引数を取れる
      tr.token = tokens[tp++];
      tr.left = ltr;
      tr.right = rtr;
      tree.right = tr;
      if (tokens[tp] && tokens[tp].type == "Number"){ // 繰返し数はleft tokenに設定
        ltr.token = tokens[tp++];
      }
      break;
    case "Note":
      tr.token = tokens[tp++];
      tr.left = ltr;
      tr.right = rtr;
      tree.right = tr;
      if (tokens[tp] && tokens[tp].type == "Sig"){ // 調号
        tr.token.sig = tokens[tp++].val;
      }
      if (tokens[tp] && tokens[tp].type == "Number"){ // 音長
        ltr.token = tokens[tp++];
        if (tokens[tp] && tokens[tp].type == "Dot"){ // 符点
          ltr.token.dot = tokens[tp++].val;
        }
      }
      break;
    case "Number":
      console.log("constructTree : Syntax error.", tokens[tp]);
      return;
    default: // 必ず引数1つを取る
      tr.token = tokens[tp++];
      tr.left = ltr;
      tr.right = rtr;
      tree.right = tr;
      ltr.token = tokens[tp++];    
  }
  constructTree(tokens, tp, tr);
}
function printTree(tr, lv){
  if (!tr.right) return;
  
  let ltr = tr.left;
  let rtr = tr.right;
  
  if (tr.token){
    var pad = "";
    for (var i = 1; i < lv; i++)
      pad += "   ";
    var txt = "  " + pad;
    txt += (tr.token) ? tr.token.val : "";
    if (tr.token){
      txt+=(tr.token.sig)?"("+tr.token.sig+")":"";
      txt+=(tr.token.broken)?"("+tr.token.broken+")":"";
    }
    txt += "\n" + pad + " / \\\n" + pad;
    txt += (ltr && ltr.token) ? ltr.token.val : "";
    if (ltr && ltr.token){
      txt+=(ltr.token.dot)?"("+ltr.token.dot+")":"";
    }
    console.log(txt);
  }
  //console.log(tr.token)
  //if (ltr) console.log(ltr.token)
  
  printTree(rtr, lv+1);
}

function parse(mml) {
  var commands = [];
  /*target = target.toLowerCase();
  
  setpos(0);
  while(getch()){
    var c = getCmd();
    if (!c)　break;
    commands.push(c);
  }*/

  var tokens = [];
  //var str = "@3 t135 o4 L16 ['c+f-a'2,32]4r".toLowerCase();
  //var str = "t135 'c-2'32,4".toLowerCase();
  var str = target.toLowerCase();
  var pos = 0;
  var cnt = 0; // stopper
  var result = tokenize(str, pos);
  while (result.token.type != null){
    tokens.push(result.token);
    
    result = tokenize(str, result.pos);
    if (++cnt > 50) break;
  }
  tokens.map(t=>{ console.log(t); });
  
  constructTree(tokens, 0, root);
  printTree(root, 0);
  
  return commands;
};


var MMLTrack2 = function() {
};

MMLTrack2.prototype.parse = function (mml) {
  var commands = [];
  var checked = {};
  var m, cmd, mask;

  commands = parse(mml);
  
  return commands;
};

function test01_read(){
  console.log("test01 start.");

  var m = new MMLTrack2();
  var cmds = m.parse(target);
  cmds.map(c=>{console.log(c);});
  
  console.log("test01 end.");
}
document.getElementById("btnTest").onclick = function(e){
  target = document.getElementById("taTest").value;
  test01_read();
};

</script>
</html>
